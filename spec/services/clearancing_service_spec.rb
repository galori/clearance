require 'rails_helper'

describe ClearancingService do

  describe "::process_file" do

    context "total success" do
      let(:items)         { 5.times.map { create(:item) } }
      let(:file_name)     { generate_csv_file(items) }
      let(:uploaded_file) { Rack::Test::UploadedFile.new(file_name) }
      let(:clearancing_service) { ClearancingService.new(uploaded_file) }

      before do
        @clearancing_status = clearancing_service.process
      end

      it "creates a clearance batch" do
        expect(@clearancing_status.batch.new_record?).to be false
      end

      it "encounters no errors" do
        expect(@clearancing_status.errors.empty?).to be true 
      end

      it "adds all the items to the batch" do
        expect(@clearancing_status.batch.items.pluck(:id).sort).to eq(items.map(&:id).sort) 
      end

      it "sets all items to 'clearanced' status" do
        expect(@clearancing_status.batch.items.pluck(:status).uniq).to eq(["clearanced"])
      end
    end

    context "partial success" do
      let(:valid_items) { 3.times.map { create(:item) } }
      let(:unsellable_item) { create(:item, status: 'clearanced') }

      let(:invalid_dress_style) { create(:style, :type => 'Dress', :wholesale_price => 5.0, :name => 'Invalid price dress') }
      let(:invalid_dress) { create(:item, :style => invalid_dress_style)}

      let(:non_existent_id) { 987654 }
      let(:invalid_id) { 'no thanks' }
      let(:no_id) { nil }
      let(:float_id) { 123.45 }
      let(:invalid_items) {
        [
          [non_existent_id],
          [invalid_id],
          [no_id],
          [float_id],
          [unsellable_item.id],
          [invalid_dress.id],
        ]
      }
      let(:file_name)         { generate_csv_file(valid_items + invalid_items) }
      let(:uploaded_file)     { Rack::Test::UploadedFile.new(file_name) }
      let(:clearancing_service) { ClearancingService.new(uploaded_file) }

      before do
        @clearancing_status = clearancing_service.process
      end

      it "detects all errors generated by invalid items" do
        expect(@clearancing_status.errors.count).to eq(invalid_items.count)
        [ invalid_id, no_id ].each do |bad_id|
          expect(@clearancing_status.errors).to include("Item id #{bad_id.to_i} is not valid")
        end

        expect(@clearancing_status.errors).to include("Item id #{non_existent_id} could not be found")
        expect(@clearancing_status.errors).to include("Item id #{float_id.to_i} could not be found")
        expect(@clearancing_status.errors).to include("Item id #{unsellable_item.id} could not be clearanced: Status clearanced can not be clearanced again")
        expect(@clearancing_status.errors).to include("Item id #{invalid_dress.id} could not be clearanced: Price sold $3.75 is too low for Item of style Dress")
      end

      it "includes all valid items in the batch" do
        expect(@clearancing_status.batch.items.pluck(:id)).to eq(valid_items.map(&:id))
      end
    end

    context "total failure" do
      let(:invalid_dress_style) { create(:style, :type => 'Dress', :wholesale_price => 5.0, :name => 'Invalid price dress') }
      let(:invalid_dress) { create(:item, :style => invalid_dress_style)}

      let(:invalid_items) { [[987654], ['no thanks'], [invalid_dress.id]] }

      let(:file_name)     { generate_csv_file(invalid_items) }
      let(:uploaded_file) { Rack::Test::UploadedFile.new(file_name) }
      let(:clearancing_service) { ClearancingService.new(uploaded_file) }

      before do
        @clearancing_status = clearancing_service.process
      end

      it "should indicate all items as having errors" do
        expect(@clearancing_status.errors.count).to eq(invalid_items.count)
      end
      it "should not create a new ClearanceBatch" do
        expect(@clearancing_status.batch.new_record?).to be true
      end
    end
  end
end
